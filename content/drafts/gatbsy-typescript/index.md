---
title: gatsby and typescript
date: "2020-03-20"
author: franleplant
description: "Docker has become a widely used
  technology and chances are you are going to have to deal with it eventually, at least superficially, in your Front End
  career. Let's cover the basic concepts and day to day useful commands you will likely use when dealing with Docker."
tags:
  - Docker
  - Dockerfile
  - Javascript
  - front end developers
  - NodeJs
  - Express
  - Cloud Computing
  - Clusters
  - Kubernetes
  - AWS
  - Azure
  - Google Compute Engine
---

## How to use Typescript in your Gatbsy.js site.

Follow these instructions

https://www.gatsbyjs.org/packages/gatsby-plugin-typescript/

Codegen https://www.gatsbyjs.org/packages/gatsby-plugin-graphql-codegen/

(it does not work well with strictNullChecks since if becomes a hussle to cast everything.
Also, since the types autogenerated have a lot of optionals and nulls and undefined and Maybe it
becomes hard to specify to the compiler that since you aksed for the data you alreadt know that
it wont be undef.

use this config

````

    {
      resolve: `gatsby-plugin-graphql-codegen`,
      options: {
        codegenConfig: {
          typesPrefix: "I",
          avoidOptionals: true,
        },
      },
    },
    ```


The `avoidOptionals` avoids adding one more potential value to the resulting enum, because
the codegen will automaticallyt generate values as

```typescript

export type SomeType = {
  attribute?: Maybe<Type>
}

````

And this evaluates to something like `Type | null | undefined`, so you basically have three potential
values and that throws a lot of errors, and it becomes unmmanagable if you have `strictNullChecks` on.

I suggest you use that.

Additionally is better to create your own types instead of tring to reuse the types that the
codegen genrates.

For example in this blog we have an authors yaml. The codegen generates this type

```typescript
export type IAuthorYaml = INode & {
  id: Scalars["ID"];
  parent: Maybe<INode>;
  children: Array<INode>;
  internal: IInternal;
  bio: Maybe<Scalars["String"]>;
  profilepicture: Maybe<IFile>;
  twitter: Maybe<Scalars["String"]>;
  github: Maybe<Scalars["String"]>;
};
```

but the pages that make the query might generate different variantes of this type. Sometime shaving
some fields sometimes others and in particular the profilepicture filed whihc maps to an image
might be altered in several forms like asking for a sharp image fluid.

IN that case this type wont be useful at all. INstead what I have is a concrete `IAuthor` type
that I defined which is very similar to this but only has the "domain" attributes I need

```typescript
export interface IAuthor {
  id: string;
  bio: string;
  twitter: string;
  github: string;
  profilepicture?: any;
}
```

and in the case of providing a particular image flui I can extend that type adhoc like this

```typescript
//TOD show the interface in BIO
```
